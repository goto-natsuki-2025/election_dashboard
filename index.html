<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>選挙集図盤</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --surface: #f8fafc;
        --card: #ffffff;
        --border: #dce4f0;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.08);
        --accent-strong: #1d4ed8;
        --text: #0f172a;
        --text-muted: #475569;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "Hiragino Sans", "Noto Sans JP", system-ui,
          -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--surface);
        color: var(--text);
        line-height: 1.6;
      }

      header {
        padding: 32px clamp(16px, 4vw, 48px);
        background: var(--card);
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: 0.03em;
      }

      header p {
        margin: 10px 0 0;
        color: var(--text-muted);
        font-size: 14px;
      }

      main {
        padding: clamp(16px, 4vw, 48px);
        display: grid;
        gap: clamp(20px, 4vw, 32px);
        max-width: 1200px;
        margin: 0 auto;
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }

      .summary-item {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 12px 34px -24px rgba(15, 23, 42, 0.25);
      }

      .summary-item span {
        color: var(--text-muted);
        font-size: 12px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .summary-item strong {
        font-size: 26px;
        font-weight: 600;
        color: var(--accent-strong);
      }

      .summary-item small {
        font-size: 12px;
        color: var(--text-muted);
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: clamp(18px, 3vw, 28px);
        box-shadow: 0 16px 40px -28px rgba(15, 23, 42, 0.28);
      }

      .card h2 {
        margin: 0 0 12px;
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .card p.description {
        margin: 0 0 20px;
        color: var(--text-muted);
        font-size: 14px;
      }

      .party-metric-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
      }

      .party-metric {
        background: rgba(37, 99, 235, 0.08);
        border-radius: 14px;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .party-metric header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        flex-wrap: wrap;
      }

      .party-metric header h3 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        color: var(--text);
      }

      .party-metric header strong {
        font-size: 24px;
        font-weight: 600;
        color: var(--accent-strong);
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
      }

      .party-metric header strong span {
        font-size: 13px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .party-metric header small {
        font-size: 12px;
        color: var(--text-muted);
        flex-basis: 100%;
        display: block;
        margin-top: 4px;
      }

      .party-metric-canvas {
        width: 100%;
        min-height: 140px;
        position: relative;
        overflow: hidden;
        border-radius: 10px;
      }

      @media (max-width: 720px) {
        .party-metric header {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }
        .party-metric header small {
          flex-basis: auto;
        }
        .party-metric-canvas {
          min-height: 180px;
        }
      }

      .chart {
        width: 100%;
        min-height: 320px;
      }

      footer {
        text-align: center;
        color: var(--text-muted);
        font-size: 12px;
        margin: 16px 0 32px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>選挙集図盤</h1>
      <p>
        直近4年間に実施された自治体選挙をもとに、政党別の所属議員数を集計し、
        全国の勢力図と推移を可視化します。
      </p>
    </header>
    <main>
      <section class="summary-grid">
        <article class="summary-item">
          <span>対象自治体</span>
          <strong id="summary-municipalities">-</strong>
          <small>直近4年以内の最新選挙を採用</small>
        </article>
        <article class="summary-item">
          <span>所属議員総数</span>
          <strong id="summary-seats">-</strong>
          <small>上記自治体で当選した議員の合計</small>
        </article>
        <article class="summary-item">
          <span>政党・会派数</span>
          <strong id="summary-parties">-</strong>
          <small>無所属を含む判明している会派数</small>
        </article>
      </section>

      <section class="card">
        <h2>政党別所属議員数（直近4年・最新選挙）</h2>
        <p class="description">
          最新選挙で当選した議員を政党・会派ごとに集計したものです。上位勢力の規模感を俯瞰できます。
        </p>
        <div class="party-metric-grid" id="party-metric-grid" aria-live="polite"></div>
      </section>

      <section class="card">
        <h2>政党別所属議員数の推移</h2>
        <p class="description">
          各自治体の最新選挙日を時系列に並べ、累積議席数の推移を描画しています。
          折れ線は政党ごとの勢力の伸び縮みを示します（上位会派のみ表示）。
        </p>
        <div id="party-trend-chart" class="chart" aria-label="政党別所属議員数の推移"></div>
      </section>
    </main>
    <footer id="data-range-note"></footer>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
            <script type="module">
      import { ungzip } from "https://cdn.jsdelivr.net/npm/pako@2.1.0/+esm";

      const DATA_PATH = {
        elections: "data/election_summary.csv",
        candidates: "data/candidate_details.csv.gz",
      };

      const WINNING_KEYWORDS = ["当選", "繰上当選", "繰り上げ当選", "信任", "補選当選"];
      const charts = [];

      function normaliseString(value) {
        return (value ?? "").toString().trim();
      }

      function isWinningOutcome(outcome) {
        const text = normaliseString(outcome).replace(/\s/g, "");
        if (!text) return false;
        return WINNING_KEYWORDS.some((keyword) => text.includes(keyword));
      }

      function ensurePartyName(name) {
        const text = normaliseString(name);
        if (!text || text === "-" || text.includes("無所属")) {
          return "無所属";
        }
        return text;
      }

      function parseYYYYMMDD(value) {
        if (!value) return null;
        const trimmed = normaliseString(value);
        const match = trimmed.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (!match) return null;
        const [, year, month, day] = match;
        return new Date(Number(year), Number(month) - 1, Number(day));
      }

      function formatDate(date) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")}`;
      }

      function formatYmd(date) {
        return `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, "0")}${String(date.getDate()).padStart(2, "0")}`;
      }

      async function loadElectionSummary() {
        const text = await fetch(DATA_PATH.elections).then((response) => {
          if (!response.ok) {
            throw new Error("election_summary.csv の取得に失敗しました");
          }
          return response.text();
        });
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data
          .map((row) => ({
            election_name: normaliseString(row.election_name),
            notice_date: row.notice_date ? new Date(row.notice_date) : null,
            election_day: row.election_day ? new Date(row.election_day) : null,
            seats: Number(row.seats) || null,
            candidate_count: Number(row.candidate_count) || null,
            registered_voters: Number(row.registered_voters) || null,
            note: normaliseString(row.note),
          }))
          .filter(
            (row) =>
              row.election_name &&
              row.election_day instanceof Date &&
              !Number.isNaN(row.election_day.getTime())
          );
      }

      function buildSummaryIndex(elections) {
        const index = new Map();
        for (const election of elections) {
          const key = election.election_name;
          if (!index.has(key)) {
            index.set(key, []);
          }
          index.get(key).push(election);
        }
        for (const list of index.values()) {
          list.sort((a, b) => b.election_day - a.election_day);
        }
        return index;
      }

      async function loadCandidateDetails(summaryIndex) {
        const response = await fetch(DATA_PATH.candidates);
        if (!response.ok) {
          throw new Error("candidate_details.csv.gz の取得に失敗しました");
        }
        const buffer = await response.arrayBuffer();
        const text = new TextDecoder("utf-8").decode(ungzip(new Uint8Array(buffer)));
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data.map((row) => {
          const rawSource = normaliseString(row.source_file);
          const cleanedSource = rawSource.replace(/\.html$/, "");
          const match = cleanedSource.match(/^(.*)_(\d{8})$/);
          const electionKey = match ? normaliseString(match[1]) : cleanedSource;
          const electionDateCode = match ? match[2] : null;
          let electionDate = parseYYYYMMDD(electionDateCode);

          if (!electionDate) {
            const summaryList = summaryIndex.get(electionKey);
            if (summaryList && summaryList.length > 0) {
              electionDate = summaryList[0].election_day;
            }
          }

          return {
            party: ensurePartyName(row.party),
            outcome: normaliseString(row.outcome),
            source_key: electionKey,
            source_date_code: electionDateCode,
            election_date: electionDate,
          };
        });
      }

      function buildElectionEvents(candidates, { startDate = null, endDate = null } = {}) {
        const eventsMap = new Map();
        const municipalitySet = new Set();

        for (const candidate of candidates) {
          const electionDate = candidate.election_date;
          if (!(electionDate instanceof Date) || Number.isNaN(electionDate?.getTime())) {
            continue;
          }
          if (startDate && electionDate < startDate) continue;
          if (endDate && electionDate > endDate) continue;

          municipalitySet.add(candidate.source_key);

          const dateCode = formatYmd(electionDate);
          const eventId = `${candidate.source_key}|${dateCode}`;

          let event = eventsMap.get(eventId);
          if (!event) {
            event = {
              key: candidate.source_key,
              date: electionDate,
              dateCode,
              winners: new Map(),
            };
            eventsMap.set(eventId, event);
          }

          if (!isWinningOutcome(candidate.outcome)) {
            continue;
          }

          const party = candidate.party;
          event.winners.set(party, (event.winners.get(party) ?? 0) + 1);
        }

        const events = Array.from(eventsMap.values()).filter((event) => event.winners.size > 0);
        return { events, municipalityCount: municipalitySet.size };
      }

      function buildPartyTimeline(events, { topN = 8 } = {}) {
        const byDate = new Map();

        for (const event of events) {
          const { date, dateCode, winners } = event;
          let bucket = byDate.get(dateCode);
          if (!bucket) {
            bucket = { date, counts: new Map() };
            byDate.set(dateCode, bucket);
          }
          for (const [party, seats] of winners.entries()) {
            bucket.counts.set(party, (bucket.counts.get(party) ?? 0) + seats);
          }
        }

        const sortedBuckets = Array.from(byDate.values()).sort((a, b) => a.date - b.date);
        const partiesSet = new Set();
        const snapshots = [];
        const cumulative = new Map();
        const dateLabels = [];

        for (const bucket of sortedBuckets) {
          for (const [party, seats] of bucket.counts.entries()) {
            partiesSet.add(party);
            cumulative.set(party, (cumulative.get(party) ?? 0) + seats);
          }

          const snapshot = {};
          for (const party of partiesSet) {
            snapshot[party] = cumulative.get(party) ?? 0;
          }
          snapshots.push(snapshot);
          dateLabels.push(formatDate(bucket.date));
        }

        const partiesOrdered = Array.from(partiesSet).sort((a, b) => {
          const lastSnapshot = snapshots[snapshots.length - 1] ?? {};
          const aVal = lastSnapshot[a] ?? 0;
          const bVal = lastSnapshot[b] ?? 0;
          return bVal - aVal;
        });

        const totals = new Map();
        const sparklineValues = new Map();
        for (const party of partiesOrdered) {
          const values = snapshots.map((snapshot) => snapshot[party] ?? 0);
          sparklineValues.set(party, values);
          totals.set(party, values.length ? values[values.length - 1] : 0);
        }

        const totalSeats = Array.from(totals.values()).reduce((sum, value) => sum + value, 0);
        const minDate = sortedBuckets.length ? sortedBuckets[0].date : null;
        const maxDate = sortedBuckets.length ? sortedBuckets[sortedBuckets.length - 1].date : null;

        const limitedParties = partiesOrdered.slice(0, topN);
        const series = limitedParties.map((party) => ({
          name: party,
          type: "line",
          smooth: true,
          showSymbol: false,
          emphasis: { focus: "series" },
          data: sparklineValues.get(party),
        }));

        return {
          dateLabels,
          series,
          parties: partiesOrdered,
          totals,
          sparklineValues,
          totalSeats,
          minDate,
          maxDate,
        };
      }

      function renderSummary({ municipalityCount, totalSeats, partyCount, minDate, maxDate }) {
        const formatNumber = (value) => value.toLocaleString("ja-JP");
        document.getElementById("summary-municipalities").textContent = formatNumber(municipalityCount);
        document.getElementById("summary-seats").textContent = formatNumber(totalSeats);
        document.getElementById("summary-parties").textContent = formatNumber(partyCount);

        if (minDate && maxDate) {
          const note = `データ期間: ${formatDate(minDate)} 〜 ${formatDate(maxDate)}（直近の選挙を集計）`;
          document.getElementById("data-range-note").textContent = note;
        } else {
          document.getElementById("data-range-note").textContent = "";
        }
      }

      function renderPartyHighlights(timeline, limit = 6) {
        const container = document.getElementById("party-metric-grid");
        container.innerHTML = "";

        const parties = timeline.parties.slice(0, limit);
        if (parties.length === 0) {
          container.textContent = "表示できるデータがありません。";
          return;
        }

        parties.forEach((party, index) => {
          const seats = timeline.totals.get(party) ?? 0;
          const values = timeline.sparklineValues.get(party) ?? [];

          const card = document.createElement("article");
          card.className = "party-metric";

          const header = document.createElement("header");

          const title = document.createElement("h3");
          title.textContent = `${index + 1}. ${party}`;

          const total = document.createElement("strong");
          total.textContent = seats.toLocaleString("ja-JP");
          const unit = document.createElement("span");
          unit.textContent = "議席";
          total.append(unit);

          const note = document.createElement("small");
          note.textContent = "累積推移";

          header.append(title, total, note);

          const chartContainer = document.createElement("div");
          chartContainer.className = "party-metric-canvas";
          chartContainer.id = `party-sparkline-${index}`;

          card.append(header, chartContainer);
          container.appendChild(card);

          if (values.some((value) => Number(value) > 0)) {
            renderSparklineChart(chartContainer, timeline.dateLabels, values);
          } else {
            renderNoDataPlaceholder(chartContainer);
          }
        });
      }

      function renderSparklineChart(element, labels, values) {
        const chart = echarts.init(element, undefined, { renderer: "svg" });
        charts.push(chart);
        chart.setOption({
          grid: { top: 8, bottom: 6, left: 6, right: 6 },
          tooltip: {
            trigger: "axis",
            valueFormatter: (value) => `${Number(value).toLocaleString("ja-JP")} 議席`,
            axisPointer: { type: "line" },
          },
          xAxis: {
            type: "category",
            boundaryGap: false,
            data: labels,
            axisLine: { show: false },
            axisTick: { show: false },
            axisLabel: { show: false },
          },
          yAxis: {
            type: "value",
            axisLine: { show: false },
            axisTick: { show: false },
            axisLabel: { show: false },
            splitLine: { show: false },
          },
          series: [
            {
              type: "line",
              data: values,
              smooth: true,
              showSymbol: false,
              lineStyle: { width: 2, color: "#2563eb" },
              areaStyle: { opacity: 0.18, color: "#93c5fd" },
            },
          ],
        });
      }

      function renderNoDataPlaceholder(element) {
        element.textContent = "データなし";
        element.style.display = "flex";
        element.style.alignItems = "center";
        element.style.justifyContent = "center";
        element.style.color = "var(--text-muted)";
        element.style.fontSize = "13px";
      }

      function renderPartyTrendChart(containerId, timeline) {
        const el = document.getElementById(containerId);
        const chart = echarts.init(el, undefined, { renderer: "svg" });
        charts.push(chart);
        chart.setOption({
          tooltip: {
            trigger: "axis",
            valueFormatter: (value) => `${Number(value).toLocaleString("ja-JP")} 議席`,
          },
          legend: {
            type: "scroll",
            top: 0,
          },
          grid: {
            top: 48,
            left: 48,
            right: 24,
            bottom: 32,
          },
          xAxis: {
            type: "category",
            boundaryGap: false,
            data: timeline.dateLabels,
            axisLabel: { rotate: 45 },
          },
          yAxis: {
            type: "value",
            axisLabel: {
              formatter: (value) => value.toLocaleString("ja-JP"),
            },
            splitLine: { show: true, lineStyle: { color: "#e2e8f0" } },
          },
          series: timeline.series,
        });
      }

      window.addEventListener("resize", () => {
        for (const chart of charts) {
          chart.resize();
        }
      });

      async function main() {
        const elections = await loadElectionSummary();
        const summaryIndex = buildSummaryIndex(elections);
        const candidates = await loadCandidateDetails(summaryIndex);

        const { events, municipalityCount } = buildElectionEvents(candidates);
        if (events.length === 0) {
          throw new Error("集計対象の選挙データが見つかりませんでした");
        }

        const timeline = buildPartyTimeline(events, { topN: 8 });
        if (timeline.series.length === 0) {
          throw new Error("政党別の推移を作成できるデータが不足しています");
        }

        renderSummary({
          municipalityCount,
          totalSeats: timeline.totalSeats,
          partyCount: timeline.parties.length,
          minDate: timeline.minDate,
          maxDate: timeline.maxDate,
        });

        renderPartyHighlights(timeline, 6);
        renderPartyTrendChart("party-trend-chart", timeline);
      }

      main().catch((error) => {
        console.error(error);
        alert([
          "データの読み込みまたは集計に失敗しました。",
          error instanceof Error ? error.message : String(error),
          "data/ ディレクトリが正しい位置にあるか確認してください。",
        ].join("\n"));
      });
    </script>
  </body>
</html>


