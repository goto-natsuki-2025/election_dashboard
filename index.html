<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>選挙集図盤</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --surface: #f8fafc;
        --card: #ffffff;
        --border: #dce4f0;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.08);
        --accent-strong: #1d4ed8;
        --text: #0f172a;
        --text-muted: #475569;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "Hiragino Sans", "Noto Sans JP", system-ui,
          -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--surface);
        color: var(--text);
        line-height: 1.6;
      }

      header {
        padding: 32px clamp(16px, 4vw, 48px);
        background: var(--card);
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: 0.03em;
      }

      header p {
        margin: 10px 0 0;
        color: var(--text-muted);
        font-size: 14px;
      }

      main {
        padding: clamp(16px, 4vw, 48px);
        display: grid;
        gap: clamp(20px, 4vw, 32px);
        max-width: 1200px;
        margin: 0 auto;
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }

      .summary-item {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 12px 34px -24px rgba(15, 23, 42, 0.25);
      }

      .summary-item span {
        color: var(--text-muted);
        font-size: 12px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .summary-item strong {
        font-size: 26px;
        font-weight: 600;
        color: var(--accent-strong);
      }

      .summary-item small {
        font-size: 12px;
        color: var(--text-muted);
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: clamp(18px, 3vw, 28px);
        box-shadow: 0 16px 40px -28px rgba(15, 23, 42, 0.28);
      }

      .card h2 {
        margin: 0 0 12px;
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .card p.description {
        margin: 0 0 20px;
        color: var(--text-muted);
        font-size: 14px;
      }

      .top-parties {
        display: grid;
        gap: 8px;
        margin: 0;
        padding: 0;
        list-style: none;
      }

      .top-parties li {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: var(--accent-soft);
        border-radius: 12px;
        padding: 12px 16px;
        font-weight: 500;
      }

      .top-parties span {
        color: var(--text-muted);
        font-size: 13px;
      }

      .chart {
        width: 100%;
        min-height: 320px;
      }

      footer {
        text-align: center;
        color: var(--text-muted);
        font-size: 12px;
        margin: 16px 0 32px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>選挙集図盤</h1>
      <p>
        直近4年間に実施された自治体選挙をもとに、政党別の所属議員数を集計し、
        全国の勢力図と推移を可視化します。
      </p>
    </header>
    <main>
      <section class="summary-grid">
        <article class="summary-item">
          <span>対象自治体</span>
          <strong id="summary-municipalities">-</strong>
          <small>直近4年以内の最新選挙を採用</small>
        </article>
        <article class="summary-item">
          <span>所属議員総数</span>
          <strong id="summary-seats">-</strong>
          <small>上記自治体で当選した議員の合計</small>
        </article>
        <article class="summary-item">
          <span>政党・会派数</span>
          <strong id="summary-parties">-</strong>
          <small>無所属を含む判明している会派数</small>
        </article>
      </section>

      <section class="card">
        <h2>政党別所属議員数（直近4年・最新選挙）</h2>
        <p class="description">
          最新選挙で当選した議員を政党・会派ごとに集計したものです。上位勢力の規模感を俯瞰できます。
        </p>
        <ol class="top-parties" id="top-parties"></ol>
      </section>

      <section class="card">
        <h2>政党別所属議員数の推移</h2>
        <p class="description">
          各自治体の最新選挙日を時系列に並べ、累積議席数の推移を描画しています。
          折れ線は政党ごとの勢力の伸び縮みを示します（上位会派のみ表示）。
        </p>
        <div id="party-trend-chart" class="chart" aria-label="政党別所属議員数の推移"></div>
      </section>
    </main>
    <footer id="data-range-note"></footer>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script type="module">
      import { ungzip } from "https://cdn.jsdelivr.net/npm/pako@2.1.0/+esm";

      const DATA_PATH = {
        elections: "data/election_summary.csv",
        candidates: "data/candidate_details.csv.gz",
      };

      const WINNING_KEYWORDS = ["当選", "繰上当選", "繰り上げ当選", "信任", "補選当選"];
      const FOUR_YEARS_MS = 1000 * 60 * 60 * 24 * 365 * 4;

      function normaliseString(value) {
        return (value ?? "").toString().trim();
      }

      function isWinningOutcome(outcome) {
        const text = normaliseString(outcome).replace(/\s/g, "");
        if (!text) return false;
        return WINNING_KEYWORDS.some((keyword) => text.includes(keyword));
      }

      function ensurePartyName(name) {
        const text = normaliseString(name);
        if (!text || text === "-" || /無所属/.test(text)) {
          return "無所属";
        }
        return text;
      }

      function parseYYYYMMDD(value) {
        if (!value) return null;
        const trimmed = normaliseString(value);
        const match = trimmed.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (!match) return null;
        const [, year, month, day] = match;
        return new Date(
          Number(year),
          Number(month) - 1,
          Number(day)
        );
      }

      function formatDate(date) {
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(
          2,
          "0"
        )}`;
      }

      function formatYmd(date) {
        return `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, "0")}${String(date.getDate()).padStart(
          2,
          "0"
        )}`;
      }

      async function loadElectionSummary() {
        const text = await fetch(DATA_PATH.elections).then((response) => {
          if (!response.ok) {
            throw new Error("election_summary.csv の取得に失敗しました");
          }
          return response.text();
        });
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data
          .map((row) => ({
            election_name: normaliseString(row.election_name),
            notice_date: row.notice_date ? new Date(row.notice_date) : null,
            election_day: row.election_day ? new Date(row.election_day) : null,
            seats: Number(row.seats) || null,
            candidate_count: Number(row.candidate_count) || null,
            registered_voters: Number(row.registered_voters) || null,
            note: normaliseString(row.note),
          }))
          .filter((row) => row.election_name && row.election_day instanceof Date && !Number.isNaN(row.election_day));
      }

      async function loadCandidateDetails() {
        const response = await fetch(DATA_PATH.candidates);
        if (!response.ok) {
          throw new Error("candidate_details.csv.gz の取得に失敗しました");
        }
        const buffer = await response.arrayBuffer();
        const text = new TextDecoder("utf-8").decode(ungzip(new Uint8Array(buffer)));
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data.map((row) => {
          const rawSource = normaliseString(row.source_file);
          const cleanedSource = rawSource.replace(/\.html$/, "");
          const match = cleanedSource.match(/^(.*)_(\d{8})$/);
          const electionKey = match ? normaliseString(match[1]) : cleanedSource;
          const electionDateCode = match ? match[2] : null;
          return {
            candidate_id: row.candidate_id,
            name: normaliseString(row.name),
            party: ensurePartyName(row.party),
            outcome: normaliseString(row.outcome),
            source_key: electionKey,
            source_date_code: electionDateCode,
          };
        });
      }

      function selectLatestElections(elections) {
        const now = new Date();
        const cutoff = new Date(now.getTime() - FOUR_YEARS_MS);
        const latestByName = new Map();

        for (const election of elections) {
          if (!(election.election_day instanceof Date)) continue;
          if (election.election_day < cutoff) continue;
          const existing = latestByName.get(election.election_name);
          if (!existing || election.election_day > existing.election_day) {
            latestByName.set(election.election_name, election);
          }
        }

        return latestByName;
      }

      function aggregateParties({ latestElections, candidates }) {
        const latestDateByKey = new Map(
          Array.from(latestElections.entries()).map(([key, election]) => [
            key,
            {
              date: election.election_day,
              dateCode: formatYmd(election.election_day),
            },
          ])
        );

        const partyTotals = new Map();
        const timelineByDate = new Map(); // dateCode -> Map(party -> count)
        let totalSeats = 0;

        for (const candidate of candidates) {
          const keyInfo = latestDateByKey.get(candidate.source_key);
          if (!keyInfo) continue;

          // 日付コードが取得できない場合は許容しつつ参加させる
          const candidateDateCode = candidate.source_date_code ?? keyInfo.dateCode;
          if (candidate.source_date_code && keyInfo.dateCode && candidate.source_date_code !== keyInfo.dateCode) {
            continue;
          }

          if (!isWinningOutcome(candidate.outcome)) continue;

          const party = ensurePartyName(candidate.party);
          const current = partyTotals.get(party) ?? 0;
          partyTotals.set(party, current + 1);
          totalSeats += 1;

          if (!timelineByDate.has(candidateDateCode)) {
            timelineByDate.set(candidateDateCode, new Map());
          }
          const dateBucket = timelineByDate.get(candidateDateCode);
          dateBucket.set(party, (dateBucket.get(party) ?? 0) + 1);
        }

        const sortedDates = Array.from(timelineByDate.keys())
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));
        const partiesBySize = Array.from(partyTotals.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([party]) => party);

        return {
          totalSeats,
          partyTotals,
          timelineByDate,
          sortedDates,
          orderedParties: partiesBySize,
        };
      }

      function buildChartSeries({ sortedDates, timelineByDate, parties, limit = 8 }) {
        const targetParties = parties.slice(0, limit);
        const dateLabels = sortedDates.map((code) => {
          const parsed = parseYYYYMMDD(code);
          if (!parsed) return code;
          return formatDate(parsed);
        });

        const series = targetParties.map((party) => {
          let running = 0;
          const data = sortedDates.map((code) => {
            const bucket = timelineByDate.get(code);
            const increment = bucket?.get(party) ?? 0;
            running += increment;
            return running;
          });
          return {
            name: party,
            type: "line",
            smooth: true,
            showSymbol: false,
            emphasis: { focus: "series" },
            data,
          };
        });

        return { dateLabels, series };
      }

      function renderSummary({ latestElectionsCount, totalSeats, partyCount, minDate, maxDate }) {
        const formatNumber = (value) => value.toLocaleString("ja-JP");
        document.getElementById("summary-municipalities").textContent = formatNumber(latestElectionsCount);
        document.getElementById("summary-seats").textContent = formatNumber(totalSeats);
        document.getElementById("summary-parties").textContent = formatNumber(partyCount);

        if (minDate && maxDate) {
          document.getElementById(
            "data-range-note"
          ).textContent = `データ期間: ${formatDate(minDate)} 〜 ${formatDate(maxDate)}（直近4年の選挙を対象）`;
        } else {
          document.getElementById("data-range-note").textContent = "";
        }
      }

      function renderTopParties(partyTotals, limit = 10) {
        const container = document.getElementById("top-parties");
        container.innerHTML = "";
        const entries = Array.from(partyTotals.entries()).sort((a, b) => b[1] - a[1]);
        for (const [index, [party, seats]] of entries.entries()) {
          if (index >= limit) break;
          const item = document.createElement("li");
          const name = document.createElement("strong");
          name.textContent = party;
          const count = document.createElement("span");
          count.textContent = `${seats.toLocaleString("ja-JP")} 議席`;
          item.append(name, count);
          container.appendChild(item);
        }
      }

      function renderPartyTrendChart(containerId, { dateLabels, series }) {
        const el = document.getElementById(containerId);
        const chart = echarts.init(el, undefined, { renderer: "svg" });
        chart.setOption({
          tooltip: {
            trigger: "axis",
            valueFormatter: (value) => `${Number(value).toLocaleString("ja-JP")} 議席`,
          },
          legend: {
            type: "scroll",
            top: 0,
          },
          grid: {
            top: 48,
            left: 48,
            right: 24,
            bottom: 32,
          },
          xAxis: {
            type: "category",
            boundaryGap: false,
            data: dateLabels,
            axisLabel: { rotate: 45 },
          },
          yAxis: {
            type: "value",
            axisLabel: {
              formatter: (value) => value.toLocaleString("ja-JP"),
            },
            splitLine: { show: true, lineStyle: { color: "#e2e8f0" } },
          },
          series,
        });

        window.addEventListener("resize", () => chart.resize());
      }

      async function main() {
        const [elections, candidates] = await Promise.all([
          loadElectionSummary(),
          loadCandidateDetails(),
        ]);

        const latestElections = selectLatestElections(elections);

        if (latestElections.size === 0) {
          throw new Error("直近4年以内に該当する選挙データが見つかりませんでした");
        }

        const aggregation = aggregateParties({
          latestElections,
          candidates,
        });

        const latestDates = Array.from(latestElections.values())
          .map((item) => item.election_day)
          .sort((a, b) => a - b);
        const minDate = latestDates[0] ?? null;
        const maxDate = latestDates[latestDates.length - 1] ?? null;

        renderSummary({
          latestElectionsCount: latestElections.size,
          totalSeats: aggregation.totalSeats,
          partyCount: aggregation.partyTotals.size,
          minDate,
          maxDate,
        });

        renderTopParties(aggregation.partyTotals);

        const chartData = buildChartSeries({
          sortedDates: aggregation.sortedDates,
          timelineByDate: aggregation.timelineByDate,
          parties: aggregation.orderedParties,
        });

        if (chartData.series.length === 0) {
          throw new Error("政党別の推移データを描画できませんでした");
        }

        renderPartyTrendChart("party-trend-chart", chartData);
      }

      main().catch((error) => {
        console.error(error);
        alert(
          [
            "データの読み込みまたは集計に失敗しました。",
            error instanceof Error ? error.message : String(error),
            "data/ ディレクトリが正しい位置にあるかを確認してください。",
          ].join("\n")
        );
      });
    </script>
  </body>
</html>
