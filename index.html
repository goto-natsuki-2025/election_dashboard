<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <title>選挙集図盤</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light;
        --surface: #f8fafc;
        --card: #ffffff;
        --border: #dce4f0;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.08);
        --accent-strong: #1d4ed8;
        --text: #0f172a;
        --text-muted: #475569;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "Hiragino Sans", "Noto Sans JP", system-ui,
          -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: var(--surface);
        color: var(--text);
        line-height: 1.6;
      }

      header {
        padding: 32px clamp(16px, 4vw, 48px);
        background: var(--card);
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: 0.03em;
      }

      header p {
        margin: 10px 0 0;
        color: var(--text-muted);
        font-size: 14px;
      }

      main {
        padding: clamp(16px, 4vw, 48px);
        display: grid;
        gap: clamp(20px, 4vw, 32px);
        max-width: 1200px;
        margin: 0 auto;
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }

      .summary-item {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: 0 12px 34px -24px rgba(15, 23, 42, 0.25);
      }

      .summary-item span {
        color: var(--text-muted);
        font-size: 12px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .summary-item strong {
        font-size: 26px;
        font-weight: 600;
        color: var(--accent-strong);
      }

      .summary-item small {
        font-size: 12px;
        color: var(--text-muted);
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: clamp(18px, 3vw, 28px);
        box-shadow: 0 16px 40px -28px rgba(15, 23, 42, 0.28);
      }

      .card h2 {
        margin: 0 0 12px;
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
      }

      .card p.description {
        margin: 0 0 20px;
        color: var(--text-muted);
        font-size: 14px;
      }

      .party-metric-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
      }

      .party-metric {
        background: rgba(37, 99, 235, 0.08);
        border-radius: 14px;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .party-metric header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
        flex-wrap: wrap;
      }

      .party-metric header h3 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
        color: var(--text);
      }

      .party-metric header strong {
        font-size: 24px;
        font-weight: 600;
        color: var(--accent-strong);
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
      }

      .party-metric header strong span {
        font-size: 13px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .party-metric header small {
        font-size: 12px;
        color: var(--text-muted);
        flex-basis: 100%;
        display: block;
        margin-top: 4px;
      }

      .party-metric-canvas {
        width: 100%;
        min-height: 140px;
        position: relative;
        overflow: hidden;
        border-radius: 10px;
      }

      @media (max-width: 720px) {
        .party-metric header {
          flex-direction: column;
          align-items: flex-start;
          gap: 8px;
        }
        .party-metric header small {
          flex-basis: auto;
        }
        .party-metric-canvas {
          min-height: 180px;
        }
      }

      .chart {
        width: 100%;
        min-height: 320px;
      }

      footer {
        text-align: center;
        color: var(--text-muted);
        font-size: 12px;
        margin: 16px 0 32px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>選挙集図盤</h1>
      <p>
        直近4年間に実施された自治体選挙をもとに、政党別の所属議員数を集計し、
        全国の勢力図と推移を可視化します。
      </p>
    </header>
    <main>
      <section class="summary-grid">
        <article class="summary-item">
          <span>対象自治体</span>
          <strong id="summary-municipalities">-</strong>
          <small>直近4年以内の最新選挙を採用</small>
        </article>
        <article class="summary-item">
          <span>所属議員総数</span>
          <strong id="summary-seats">-</strong>
          <small>上記自治体で当選した議員の合計</small>
        </article>
        <article class="summary-item">
          <span>政党・会派数</span>
          <strong id="summary-parties">-</strong>
          <small>無所属を含む判明している会派数</small>
        </article>
      </section>

      <section class="card">
        <h2>政党別所属議員数（直近4年・最新選挙）</h2>
        <p class="description">
          最新選挙で当選した議員を政党・会派ごとに集計したものです。上位勢力の規模感を俯瞰できます。
        </p>
        <div class="party-metric-grid" id="party-metric-grid" aria-live="polite"></div>
      </section>

      <section class="card">
        <h2>政党別所属議員数の推移</h2>
        <p class="description">
          各自治体の最新選挙日を時系列に並べ、累積議席数の推移を描画しています。
          折れ線は政党ごとの勢力の伸び縮みを示します（上位会派のみ表示）。
        </p>
        <div id="party-trend-chart" class="chart" aria-label="政党別所属議員数の推移"></div>
      </section>
    </main>
    <footer id="data-range-note"></footer>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
                <script type="module">
      import { ungzip } from "https://cdn.jsdelivr.net/npm/pako@2.1.0/+esm";

      const DATA_PATH = {
        elections: "data/election_summary.csv",
        candidates: "data/candidate_details.csv.gz",
      };

      const WINNING_KEYWORDS = ["当選", "繰上当選", "繰り上げ当選", "信任", "補選当選"];
      const TERM_YEARS = 4;
      const charts = [];

      function normaliseString(value) {
        return (value ?? "").toString().trim();
      }

      function isWinningOutcome(outcome) {
        const text = normaliseString(outcome).replace(/\s/g, "");
        if (!text) return false;
        return WINNING_KEYWORDS.some((keyword) => text.includes(keyword));
      }

      function ensurePartyName(name) {
        const text = normaliseString(name);
        if (!text || text === "-" || text.includes("無所属")) {
          return "無所属";
        }
        return text;
      }

      function parseYYYYMMDD(value) {
        if (!value) return null;
        const trimmed = normaliseString(value);
        const match = trimmed.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (!match) return null;
        const [, year, month, day] = match;
        return new Date(Number(year), Number(month) - 1, Number(day));
      }

      function formatDate(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      function formatYmd(date) {
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}${m}${d}`;
      }

      async function loadElectionSummary() {
        const text = await fetch(DATA_PATH.elections).then((response) => {
          if (!response.ok) {
            throw new Error("election_summary.csv の取得に失敗しました");
          }
          return response.text();
        });
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data
          .map((row) => ({
            election_name: normaliseString(row.election_name),
            notice_date: row.notice_date ? new Date(row.notice_date) : null,
            election_day: row.election_day ? new Date(row.election_day) : null,
            seats: Number(row.seats) || null,
            candidate_count: Number(row.candidate_count) || null,
            registered_voters: Number(row.registered_voters) || null,
            note: normaliseString(row.note),
          }))
          .filter(
            (row) =>
              row.election_name &&
              row.election_day instanceof Date &&
              !Number.isNaN(row.election_day.getTime())
          );
      }

      function buildSummaryIndex(elections) {
        const index = new Map();
        for (const election of elections) {
          const key = election.election_name;
          if (!index.has(key)) {
            index.set(key, []);
          }
          index.get(key).push(election);
        }
        for (const list of index.values()) {
          list.sort((a, b) => b.election_day - a.election_day);
        }
        return index;
      }

      async function loadCandidateDetails(summaryIndex) {
        const response = await fetch(DATA_PATH.candidates);
        if (!response.ok) {
          throw new Error("candidate_details.csv.gz の取得に失敗しました");
        }
        const buffer = await response.arrayBuffer();
        const text = new TextDecoder("utf-8").decode(ungzip(new Uint8Array(buffer)));
        const parsed = Papa.parse(text, {
          header: true,
          dynamicTyping: false,
          skipEmptyLines: true,
        });
        return parsed.data.map((row) => {
          const rawSource = normaliseString(row.source_file);
          const cleanedSource = rawSource.replace(/\.html$/, "");
          const match = cleanedSource.match(/^(.*)_(\d{8})$/);
          const electionKey = match ? normaliseString(match[1]) : cleanedSource;
          const electionDateCode = match ? match[2] : null;
          let electionDate = parseYYYYMMDD(electionDateCode);

          if (!electionDate) {
            const summaryList = summaryIndex.get(electionKey);
            if (summaryList && summaryList.length > 0) {
              electionDate = summaryList[0].election_day;
            }
          }

          return {
            party: ensurePartyName(row.party),
            outcome: normaliseString(row.outcome),
            source_key: electionKey,
            source_date_code: electionDateCode,
            election_date: electionDate,
          };
        });
      }

      function buildElectionEvents(candidates, { startDate = null, endDate = null } = {}) {
        const eventsMap = new Map();
        const municipalitySet = new Set();

        for (const candidate of candidates) {
          const electionDate = candidate.election_date;
          if (!(electionDate instanceof Date) || Number.isNaN(electionDate?.getTime())) {
            continue;
          }
          if (startDate && electionDate < startDate) continue;
          if (endDate && electionDate > endDate) continue;

          municipalitySet.add(candidate.source_key);

          const dateCode = formatYmd(electionDate);
          const eventId = `${candidate.source_key}|${dateCode}`;

          let event = eventsMap.get(eventId);
          if (!event) {
            event = {
              key: candidate.source_key,
              date: electionDate,
              dateCode,
              winners: new Map(),
            };
            eventsMap.set(eventId, event);
          }

          if (!isWinningOutcome(candidate.outcome)) {
            continue;
          }

          const party = candidate.party;
          event.winners.set(party, (event.winners.get(party) ?? 0) + 1);
        }

        const events = Array.from(eventsMap.values()).filter((event) => event.winners.size > 0);
        return { events, municipalityCount: municipalitySet.size };
      }

      function buildPartyTimeline(events, { topN = 8, termYears = TERM_YEARS } = {}) {
        if (events.length === 0) {
          return {
            dateLabels: [],
            series: [],
            parties: [],
            totals: new Map(),
            sparklineValues: new Map(),
            totalSeats: 0,
            minDate: null,
            maxDate: null,
          };
        }

        const timelineEvents = [];
        const eventsByKey = new Map();
        for (const event of events) {
          if (!eventsByKey.has(event.key)) {
            eventsByKey.set(event.key, []);
          }
          eventsByKey.get(event.key).push(event);
        }

        for (const list of eventsByKey.values()) {
          list.sort((a, b) => a.date - b.date);
          for (let index = 0; index < list.length; index += 1) {
            const event = list[index];
            const termId = `${event.key}-${event.date.getTime()}`;
            timelineEvents.push({
              type: "election",
              date: event.date,
              dateCode: event.dateCode,
              key: event.key,
              winners: event.winners,
              termId,
            });

            let expirationDate;
            const nextEvent = list[index + 1];
            if (nextEvent) {
              expirationDate = new Date(nextEvent.date.getTime());
            } else {
              expirationDate = new Date(event.date.getTime());
              expirationDate.setFullYear(expirationDate.getFullYear() + termYears);
            }

            timelineEvents.push({
              type: "expiration",
              date: expirationDate,
              dateCode: formatYmd(expirationDate),
              key: event.key,
              winners: event.winners,
              termId,
            });
          }
        }

        timelineEvents.sort((a, b) => {
          const diff = a.date - b.date;
          if (diff !== 0) return diff;
          if (a.type === b.type) return 0;
          return a.type === "expiration" ? -1 : 1;
        });

        const changeMap = new Map();
        const activeTerms = new Map();

        function applyChange(dateCode, date, party, delta) {
          let bucket = changeMap.get(dateCode);
          if (!bucket) {
            bucket = { date, deltas: new Map() };
            changeMap.set(dateCode, bucket);
          }
          if (bucket.date > date) {
            bucket.date = date;
          }
          const next = (bucket.deltas.get(party) ?? 0) + delta;
          if (Math.abs(next) < 1e-9) {
            bucket.deltas.delete(party);
          } else {
            bucket.deltas.set(party, next);
          }
        }

        for (const event of timelineEvents) {
          if (event.type === "expiration") {
            const current = activeTerms.get(event.key);
            if (!current || current.termId !== event.termId) {
              continue;
            }
            event.winners.forEach((count, party) => {
              applyChange(event.dateCode, event.date, party, -count);
            });
            activeTerms.delete(event.key);
            continue;
          }

          const current = activeTerms.get(event.key);
          if (current) {
            current.seats.forEach((count, party) => {
              applyChange(event.dateCode, event.date, party, -count);
            });
          }

          const clone = new Map();
          event.winners.forEach((count, party) => {
            applyChange(event.dateCode, event.date, party, count);
            clone.set(party, count);
          });
          activeTerms.set(event.key, { termId: event.termId, seats: clone });
        }

        const sortedChanges = Array.from(changeMap.values())
          .filter((bucket) => bucket.deltas.size > 0)
          .sort((a, b) => a.date - b.date);

        if (sortedChanges.length === 0) {
          return {
            dateLabels: [],
            series: [],
            parties: [],
            totals: new Map(),
            sparklineValues: new Map(),
            totalSeats: 0,
            minDate: null,
            maxDate: null,
          };
        }

        const now = new Date();
        let effectiveChanges = sortedChanges.filter((bucket) => bucket.date <= now);
        if (effectiveChanges.length === 0) {
          effectiveChanges = sortedChanges;
        }

        const partiesSet = new Set();
        effectiveChanges.forEach((bucket) => {
          bucket.deltas.forEach((_, party) => partiesSet.add(party));
        });

        const runningTotals = new Map();
        const sparklineValues = new Map();
        partiesSet.forEach((party) => {
          runningTotals.set(party, 0);
          sparklineValues.set(party, []);
        });

        const dateLabels = [];
        for (const bucket of effectiveChanges) {
          bucket.deltas.forEach((delta, party) => {
            const next = (runningTotals.get(party) ?? 0) + delta;
            runningTotals.set(party, Math.max(next, 0));
          });
          partiesSet.forEach((party) => {
            sparklineValues.get(party).push(runningTotals.get(party) ?? 0);
          });
          dateLabels.push(formatDate(bucket.date));
        }

        const totals = new Map();
        sparklineValues.forEach((values, party) => {
          const last = values.length ? values[values.length - 1] : 0;
          if (last > 0) {
            totals.set(party, last);
          } else {
            sparklineValues.delete(party);
          }
        });

        const partiesOrdered = Array.from(totals.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([party]) => party);

        const limitedParties = partiesOrdered.slice(0, topN);
        const series = limitedParties.map((party) => ({
          name: party,
          type: "line",
          smooth: true,
          showSymbol: false,
          emphasis: { focus: "series" },
          data: sparklineValues.get(party) ?? [],
        }));

        const totalSeats = Array.from(totals.values()).reduce((sum, value) => sum + value, 0);
        const minDate = effectiveChanges[0].date;
        const maxDate = effectiveChanges[effectiveChanges.length - 1].date;

        return {
          dateLabels,
          series,
          parties: partiesOrdered,
          totals,
          sparklineValues,
          totalSeats,
          minDate,
          maxDate,
        };
      }

      function renderSummary({ municipalityCount, totalSeats, partyCount, minDate, maxDate }) {
        const formatNumber = (value) => value.toLocaleString("ja-JP");
        document.getElementById("summary-municipalities").textContent = formatNumber(municipalityCount);
        document.getElementById("summary-seats").textContent = formatNumber(totalSeats);
        document.getElementById("summary-parties").textContent = formatNumber(partyCount);

        if (minDate && maxDate) {
          const note = `Data range: ${formatDate(minDate)} - ${formatDate(maxDate)} (active seats)`;
          document.getElementById("data-range-note").textContent = note;
        } else {
          document.getElementById("data-range-note").textContent = "";
        }
      }

      function renderPartyHighlights(timeline, limit = 6) {
        const container = document.getElementById("party-metric-grid");
        container.innerHTML = "";

        const parties = timeline.parties.slice(0, limit);
        if (parties.length === 0) {
          container.textContent = "No data available.";
          return;
        }

        parties.forEach((party, index) => {
          const seats = timeline.totals.get(party) ?? 0;
          const values = timeline.sparklineValues.get(party) ?? [];

          const card = document.createElement("article");
          card.className = "party-metric";

          const header = document.createElement("header");
          const title = document.createElement("h3");
          title.textContent = `${index + 1}. ${party}`;

          const total = document.createElement("strong");
          total.textContent = seats.toLocaleString("ja-JP");
          const unit = document.createElement("span");
          unit.textContent = "議席";
          total.append(unit);

          const note = document.createElement("small");
          note.textContent = "Active trend";

          header.append(title, total, note);

          const chartContainer = document.createElement("div");
          chartContainer.className = "party-metric-canvas";
          chartContainer.id = `party-sparkline-${index}`;

          card.append(header, chartContainer);
          container.appendChild(card);

          if (values.some((value) => Number(value) > 0)) {
            renderSparklineChart(chartContainer, timeline.dateLabels, values);
          } else {
            renderNoDataPlaceholder(chartContainer);
          }
        });
      }

      function renderSparklineChart(element, labels, values) {
        const chart = echarts.init(element, undefined, { renderer: "svg" });
        charts.push(chart);
        chart.setOption({
          grid: { top: 8, bottom: 6, left: 6, right: 6 },
          tooltip: {
            trigger: "axis",
            valueFormatter: (value) => `${Number(value).toLocaleString("ja-JP")} 議席`,
            axisPointer: { type: "line" },
          },
          xAxis: {
            type: "category",
            boundaryGap: false,
            data: labels,
            axisLine: { show: false },
            axisTick: { show: false },
            axisLabel: { show: false },
          },
          yAxis: {
            type: "value",
            axisLine: { show: false },
            axisTick: { show: false },
            axisLabel: { show: false },
            splitLine: { show: false },
          },
          series: [
            {
              type: "line",
              data: values,
              smooth: true,
              showSymbol: false,
              lineStyle: { width: 2, color: "#2563eb" },
              areaStyle: { opacity: 0.18, color: "#93c5fd" },
            },
          ],
        });
      }

      function renderNoDataPlaceholder(element) {
        element.textContent = "No data";
        element.style.display = "flex";
        element.style.alignItems = "center";
        element.style.justifyContent = "center";
        element.style.color = "var(--text-muted)";
        element.style.fontSize = "13px";
      }

      function renderPartyTrendChart(containerId, timeline) {
        const el = document.getElementById(containerId);
        const chart = echarts.init(el, undefined, { renderer: "svg" });
        charts.push(chart);
        chart.setOption({
          tooltip: {
            trigger: "axis",
            valueFormatter: (value) => `${Number(value).toLocaleString("ja-JP")} 議席`,
          },
          legend: {
            type: "scroll",
            top: 0,
          },
          grid: {
            top: 48,
            left: 48,
            right: 24,
            bottom: 32,
          },
          xAxis: {
            type: "category",
            boundaryGap: false,
            data: timeline.dateLabels,
            axisLabel: { rotate: 45 },
          },
          yAxis: {
            type: "value",
            axisLabel: {
              formatter: (value) => value.toLocaleString("ja-JP"),
            },
            splitLine: { show: true, lineStyle: { color: "#e2e8f0" } },
          },
          series: timeline.series,
        });
      }

      window.addEventListener("resize", () => {
        for (const chart of charts) {
          chart.resize();
        }
      });

      async function main() {
        const elections = await loadElectionSummary();
        const summaryIndex = buildSummaryIndex(elections);
        const candidates = await loadCandidateDetails(summaryIndex);

        const { events, municipalityCount } = buildElectionEvents(candidates);
        if (events.length === 0) {
          throw new Error("No election data matched the aggregation criteria");
        }

        const timeline = buildPartyTimeline(events, { topN: 8 });
        if (timeline.series.length === 0 || timeline.dateLabels.length === 0) {
          throw new Error("Insufficient data to build the party timeline");
        }

        renderSummary({
          municipalityCount,
          totalSeats: timeline.totalSeats,
          partyCount: timeline.parties.length,
          minDate: timeline.minDate,
          maxDate: timeline.maxDate,
        });

        renderPartyHighlights(timeline, 6);
        renderPartyTrendChart("party-trend-chart", timeline);
      }

      main().catch((error) => {
        console.error(error);
        alert([
          "Failed to load or process the data.",
          error instanceof Error ? error.message : String(error),
          "Confirm that the data/ directory is located correctly.",
        ].join("\n"));
      });
    </script>
  </body>
</html>




